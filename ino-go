#!/usr/bin/env tclsh

# A front-end to `ino` (inotool) which tries to be smart about detecting Arduino-type devices and prompts the user when necessary (or asked) for which device to use.
# CME 2015-06-06

# NOTE: when called from Geany, it'll be in the wrong location (src, rather than the parent of src). Can we configure Geany to start in the right place, or should we handle it here?  Consider that this file could be called from the shell in the correct build location!  Or perhaps accept an optional argument that Geany can pass so we can move relative to there.

puts "argv = $argv"
#puts [llength $argv]
if {[llength $argv] == 1} {
	puts CDing
	set dir [file dirname [lindex $argv 0]]
	puts "Will cd to $dir"
	cd $dir
	set env(PWD) $dir
}

#puts $env(PWD)
puts "pwd is now [pwd]"

puts "\nChris's `ino` front-end, (C) 2015 Chris Edwards"

# Not because it's likely to change, but to get relative link following to work later on:
set by_id_path /dev/serial/by-id

# TODO: consider what to do if there are multiple devices of the same USB ID?
# Oh, they can still be distinguished by the canonical serial device special file name,
# e.g. /dev/ttyACM2
# For this first stuff we only care about identifying what type of device corresponds to each serial device. We use the by-id ones since they include distinctive strings that should let us infer the device type.

# First up, a "database" (haha) of known Arduino and compatible models:

# Older Arduino Mega (1280):
# Damn, these are indistinguishable from other FTDI-connected devices..?!
# I don't think we can reliably infer the board type for these. :(
# Funduino Nano: /dev/serial/by-id/usb-FTDI_FT232R_USB_UART_A603ANIP-if00-port0
set dev_substring(0403:6001) FTDI_FT232R
set ino_model(0403:6001) mega
set model_label(0403:6001) {FDTI-connected device (older Arduino Mega ATmega1280, Funduino Nano, etc.))}

# Arduino Mega 2560:
set dev_substring(2341:0042) Arduino__www.arduino.cc__0042_
set ino_model(2341:0042) mega2560
set model_label(2341:0042) {Arduino Mega 2560 or Mega ADK}

# Arduino Leonardo and clones (incl. early Freetronics Leostick, DSpace SMD kit):
set dev_substring(2341:8036) Arduino_LLC_Arduino_Leonardo
set ino_model(2341:8036) leonardo
set model_label(2341:8036) {Arduino Leonardo, Freetronics Leostick v1.0, DSpace SMD kit board, etc.}

# TODO: all the other official Arduino models


# Freetronics Eleven:
set dev_substring(26ba:0003) www.freetronics.com_0003
set ino_model(26ba:0003) uno
set model_label(26ba:0003) {Freetronics Eleven}

# TODO: Freetronics USBDroid:
# ...

# Freetronics Leostick (v2.0 bootloader?):
# NOTE: the older ones appear as 2341:8036 (Arduino Leonardo)! But maybe treating them as Leonardos is fine.
set dev_substring(26ba:8002) Unknown_USB_IO_Board
set ino_model(26ba:8002) leonardo
set model_label(26ba:8002) {Freetronics Leostick}

# DSpace badge kit + base:
set dev_substring(03eb:204b) Donald_Delmar_Davis_Benito7g
set ino_model(03eb:204b) dspace_badge_unknown
set model_label(03eb:204b) {DSpace Badge Kit}

# TODO: DSpace Robot kit:
set dev_substring(03eb:20??) REPLACE_ME
set ino_model(03eb:20??) dspace_robot_unknown
set model_label(03eb:20??) {DSpace Robot}


set known_devices [array names dev_substring]


# That's it for the general IDs.

# Now to detect and recognise...


# Here we should really be building another database based on the current scan. I don't think we can really just return a value, sadly (maybe a structured list, but arrays would be nicer, and lend themselves to later updating if the guessed model is wrong).
# The devices found during the scan are keyed by e.g. /dev/ttyACM0 rather than USB device ID.

array unset found_devices

proc scan {} {
	global known_devices dev_substring ino_model model_label
	global found_usb_id found_ino_model found_model_label
	set candidate_devices [list]
	foreach device [glob -nocomplain /dev/serial/by-id/*] {
		foreach id $known_devices {
			if {[string match *$dev_substring($id)* $device]} {
			#	puts $ino_model($id)
				set dev [file normalize /dev/serial/by-id/[file readlink $device]]
				set found_usb_id($dev) $id
				set found_ino_model($dev) $ino_model($id)
				set found_model_label($dev) $model_label($id)
			#	lappend candidate_devices $id
				lappend candidate_devices $dev
			}
		}
	}
	return $candidate_devices
}

#puts $candidate_devices
#foreach id [scan] {puts "$id: $model_label($id) ($ino_model($id))"}

# Should we also determine the canonical USB device special file name, e.g. /dev/ttyACM2? Or is that not really relevant, given how subject to change they are (not to mention user-unfriendly)?  Can we do that using Tcl's file command perhaps?

puts "\nFound devices:"
foreach dev [lsort [scan]] {puts "$dev: $found_usb_id($dev) $found_model_label($dev) ($found_ino_model($dev))"}
#puts "\n"

# Invoke zenity to prompt for which device to program? Even if there's only one candidate?! (could be a good idea to avoid accidentally reprogramming the wrong device)

# zenity --title="Available Arduino Devices" --list --text="Choose the device to program:" --separator=';' --width=500 --height=200 --column="Device:" --column="USB ID:" --column="ino model:" --column="Type" 1 2 3 4 5 6 7 8

# So, how to build the list of values in Tcl? And run it properly?!

set zenity_exec_command [list]
lappend zenity_exec_command exec -ignorestderr zenity {--title=Available Arduino Devices} --list {--text=Choose the device to program:} --separator=| --width=500 --height=200 --column=Device: {--column=USB ID:} {--column=ino model:} --column=Type:

# Tack on the found Arduino-type device details to the zenity command line:
foreach dev [lsort [scan]] {
	lappend zenity_exec_command $dev
	lappend zenity_exec_command $found_usb_id($dev)
	lappend zenity_exec_command $found_ino_model($dev)
	lappend zenity_exec_command $found_model_label($dev)
}

#puts $zenity_exec_command
puts "Launching zenity..."
# TODO: maybe replace zenity with a Tk GUI?!

set selected_device [{*}$zenity_exec_command]

puts "choice = $selected_device"

set model $found_ino_model($selected_device)
set serial $selected_device

# TODO: create .ini file (or allow user to choose whether this is a one-off?)
puts "Building code..."
set build_result  [exec -ignorestderr ino build -m $model]
puts "Uploading..."
set upload_result [exec -ignorestderr ino upload -m $model -p $serial]

puts $build_result
puts $upload_result
